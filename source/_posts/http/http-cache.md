---
title: HTTP cache
date: 2023-05-14
---


> HTTP 缓存的历史 

# 缓存的优点
1. 减少了传输数据的冗余
2. 减少了带宽的占用
3. 减少了服务器的开销
4. 降低了时延，增加了用户效率

# 缓存方式
主要包括，浏览器缓存、代理服务器缓存，http协议中的强缓存和协商缓存。


# 浏览器缓存与HTTP缓存

## 缓存命中
> 缓存命中与否分为三种情况
1. 缓存命中 cache hit - 200(memory cache, disk cache)
2. 缓存未命中 cache miss - 200
3. 缓存再验证 cache revalidation
    再验证缓存命中 revalidation hit - 304
    再验证缓存未命中 revalidation miss - 200


## 浏览器缓存
内存缓存：
    当浏览器加载一个页面时，它会将页面中的静态资源（例如脚本、样式、图片等）缓存到内存中。这些资源可以快速加载，因为它们在内存中的访问速度比在硬盘中的快得多。内存缓存的原理是将资源加载到浏览器内存中，并在后续请求该资源时，直接从内存中读取，不再向服务器发送请求。
磁盘缓存：
    当浏览器第一次加载一个页面时，它会将页面中的静态资源（例如脚本、样式、图片等）缓存到磁盘中。这些资源可以在后续访问时快速加载，因为它们已经被缓存在磁盘中。磁盘缓存的原理是将资源写入到硬盘中，并在后续请求该资源时，先从硬盘中读取，如果存在，则不再向服务器发送请求，而是直接返回缓存的数据。
二者的一个显著特点是，内存缓存的数据会随着浏览器的关闭而失效，而磁盘缓存的数据会一直保留，直到过期或者手动清除。

## 强缓存
1. Cache-Control: max-age=xxx(s) and Expires (HTTP/1.0)
max-age 可以设置一个相对时间，而Expires 只能设置一个j绝对时间，如果同时存在，max-age 优先级高于 Expires.
使用场景是：
当设置 `cache-control: max-age=3600`时，在1个小时内，浏览器都会直接从缓存中读取资源，而不会向服务器发送请求。当超过一个小时时，浏览器才会向服务器发送请求，获取最新的资源。
当设置 `Expires: Wed, 21 Oct 2020 07:28:00 GMT` 时，在2020年10月21日07:28:00之前，浏览器都会直接从缓存中读取资源，而不会向服务器发送请求。当超过这个时间时，浏览器才会向服务器发送请求，获取最新的资源。

**相对来说maxage 会比expires 来的更加灵活**
当资源的有效期比较短，例如一些动态资源，可以使用 max-age，当资源的有效期比较长，例如一些静态资源，可以使用 Expires。

## 协商缓存
**服务器再验证**、**缓存过期**.
场景是：
`cache-control and expires` 过期时，这时不代表缓存是不能用了。而是需要向服务器发送请求，验证缓存是否可用。
1. 如果验证的内容发生了变化，那么服务器会返回最新的资源，更新缓存服务器，且返回到客户端；
2. 如果验证的内容没有发生改变，那么服务器会返回304，告诉客户端直接使用缓存。
使用协商缓存，通过**条件缓存字段**实现。

## 条件缓存字段
1. If-Modified-Since/Last-Modified and IF-None-Match/Etag
2. 

# Q&A

1. 如何操作使得浏览器未命中**内存缓存**？
    打开一个新的私密窗口：使用浏览器的私密模式，可以避免使用内存缓存，因为私密模式通常不会将任何数据缓存在内存中。

    禁用缓存功能：在浏览器开发者工具中，可以勾选禁用缓存选项，这样每次刷新页面都会从服务器重新获取资源，而不会使用内存缓存。

    强制刷新页面：在浏览器中按下 Ctrl+F5（Windows）或 Cmd+Shift+R（Mac）键，可以强制浏览器忽略本地缓存和代理缓存，重新请求页面资源。

    修改请求头：在每次请求资源时，可以通过修改请求头信息，告诉服务器不要返回缓存数据。例如，在请求头中加入 "Cache-Control: no-cache" 或 "Pragma: no-cache" 等字段，就可以避免使用内存缓存。

